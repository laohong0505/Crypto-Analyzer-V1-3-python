# -*- coding: utf-8 -*-
"""
Crypto Shortâ€‘Signal Analyzer
Version: 1.3
Author : ChatGPT (Surf) â€” pyqtgraph + å›æµ‹ + é…ç½®å¯¼å…¥å¯¼å‡º
è¯´æ˜ï¼š
 - ä½¿ç”¨ QThread åå°æ‹‰å–ä¸è®¡ç®—ï¼Œé¿å… UI å¡æ­»
 - ç”¨é…ç½®å¯¹è±¡æ›¿ä»£å…¨å±€å¯å˜å¼€å…³
 - åµŒå…¥ pyqtgraph åšäº¤äº’å¼å›¾è¡¨ï¼Œæ›¿ä»£ matplotlib å¼¹çª—
 - å¢åŠ å†å²å›æµ‹æ¨¡å—ï¼ˆä¿¡å·å›æµ‹ï¼šèƒœç‡ã€æ”¶ç›Šã€æœ€å¤§å›æ’¤ï¼‰
 - æ”¯æŒé…ç½®å¯¼å‡º/å¯¼å…¥ä¸º JSON
 - æä¾› PyInstaller æ‰“åŒ…è¯´æ˜ä¸ç”Ÿæˆè„šæœ¬

ä¾èµ–ï¼šccxt, pandas, numpy, PyQt5, pyqtgraph
å¯é€‰ï¼ˆç”¨äºæ‰“åŒ…æµ‹è¯•æ—¶å®‰è£…åœ¨è™šæ‹Ÿç¯å¢ƒï¼‰ï¼špyinstaller

æ³¨æ„ï¼šæœ¬è„šæœ¬ä»…ç”¨äºç­–ç•¥åˆ†æä¸æ•™å­¦ç¤ºä¾‹ï¼Œä¸åŒ…å«ä»»ä½•è‡ªåŠ¨ä¸‹å•æˆ–ç§é’¥ç®¡ç†ã€‚
"""

import sys
import re
import time
import json
import traceback
from typing import Optional, Tuple, Dict

import ccxt
import numpy as np
import pandas as pd

from PyQt5 import QtCore, QtGui, QtWidgets
import pyqtgraph as pg

# --------------------------- é…ç½®ç±» --------------------------- #
class AnalyzerConfig:
    def __init__(self):
        # æŒ‡æ ‡å‚æ•°
        self.ema_spans = (9, 21, 55)
        self.macd = (12, 26, 9)
        self.rsi_period = 14
        self.atr_period = 14

        # äº¤æ˜“é˜ˆå€¼
        self.rsi_overbought = 70
        self.rsi_oversold = 30
        self.vol_multiplier = 1.5
        self.atr_factor_min = 1.0
        self.atr_factor_max = 1.5

        # å¯é€‰æ‰©å±•
        self.ext = {
            "BBW": False,
            "KC": False,
            "STOCH": False,
            "ADX": False,
            "OBV": False,
            "CMF": False,
            "OBI": False,
            "SENTIMENT": False,
        }

        # ç½‘ç»œ/é‡è¯•è®¾ç½®
        self.fetch_timeout_ms = 20000
        self.fetch_retries = 2
        self.rate_limit_sleep = 0.2

    def to_dict(self) -> dict:
        return {
            'ema_spans': list(self.ema_spans),
            'macd': list(self.macd),
            'rsi_period': self.rsi_period,
            'atr_period': self.atr_period,
            'rsi_overbought': self.rsi_overbought,
            'rsi_oversold': self.rsi_oversold,
            'vol_multiplier': self.vol_multiplier,
            'atr_factor_min': self.atr_factor_min,
            'atr_factor_max': self.atr_factor_max,
            'ext': self.ext,
            'fetch_timeout_ms': self.fetch_timeout_ms,
            'fetch_retries': self.fetch_retries,
            'rate_limit_sleep': self.rate_limit_sleep,
        }

    @classmethod
    def from_dict(cls, d: dict):
        c = cls()
        try:
            c.ema_spans = tuple(d.get('ema_spans', c.ema_spans))
            c.macd = tuple(d.get('macd', c.macd))
            c.rsi_period = int(d.get('rsi_period', c.rsi_period))
            c.atr_period = int(d.get('atr_period', c.atr_period))
            c.rsi_overbought = float(d.get('rsi_overbought', c.rsi_overbought))
            c.rsi_oversold = float(d.get('rsi_oversold', c.rsi_oversold))
            c.vol_multiplier = float(d.get('vol_multiplier', c.vol_multiplier))
            c.atr_factor_min = float(d.get('atr_factor_min', c.atr_factor_min))
            c.atr_factor_max = float(d.get('atr_factor_max', c.atr_factor_max))
            ext = d.get('ext', {})
            if isinstance(ext, dict):
                c.ext.update(ext)
            c.fetch_timeout_ms = int(d.get('fetch_timeout_ms', c.fetch_timeout_ms))
            c.fetch_retries = int(d.get('fetch_retries', c.fetch_retries))
            c.rate_limit_sleep = float(d.get('rate_limit_sleep', c.rate_limit_sleep))
        except Exception:
            pass
        return c

# --------------------------- åå° Worker --------------------------- #
class AnalysisWorker(QtCore.QThread):
    finished = QtCore.pyqtSignal(dict)
    error = QtCore.pyqtSignal(str)

    def __init__(self, symbol: str, timeframe: str, mode: str, config: AnalyzerConfig, fetch_limit: int = 500):
        super().__init__()
        self.symbol = symbol
        self.timeframe = timeframe
        self.mode = mode
        self.config = config
        self.fetch_limit = fetch_limit
        self._is_running = True

    def stop(self):
        self._is_running = False

    def run(self):
        try:
            df = self._fetch_ohlcv_with_retry(self.symbol, self.timeframe, limit=self.fetch_limit)
            if df is None or df.empty:
                self.error.emit("æœªèƒ½è·å–åˆ°æœ‰æ•ˆçš„ K çº¿æ•°æ®")
                return

            ind = self._calculate_indicators(df)
            res = self._evaluate_signal(df, ind, self.mode)
            res['df'] = df
            self.finished.emit(res)
        except Exception as e:
            tb = traceback.format_exc()
            self.error.emit(f"Exception: {e}\n{tb}")

    def _make_exchange(self, for_futures: bool = False):
        opts = {'enableRateLimit': True, 'timeout': self.config.fetch_timeout_ms}
        if for_futures:
            opts['options'] = {'defaultType': 'future'}
        return ccxt.binance(opts)

    def _fetch_ohlcv_with_retry(self, symbol: str, timeframe: str, limit: int = 200) -> Optional[pd.DataFrame]:
        symbol = re.sub(r'[^A-Za-z0-9]', '', symbol).upper()
        market = f"{symbol}/USDT"
        for attempt in range(self.config.fetch_retries + 1):
            try:
                exchange = self._make_exchange(for_futures=(self.mode == 'futures'))
                data = exchange.fetch_ohlcv(market, timeframe=timeframe, limit=limit)
                df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                df.set_index('timestamp', inplace=True)
                time.sleep(self.config.rate_limit_sleep)
                return df
            except ccxt.BaseError as e:
                if attempt < self.config.fetch_retries:
                    time.sleep(1 + attempt * 0.5)
                    continue
                else:
                    raise
            except Exception:
                raise
        return None

    def _calculate_indicators(self, df: pd.DataFrame) -> dict:
        close = df['close']
        high = df['high']
        low = df['low']
        volume = df['volume']

        # EMA
        ema = {}
        for s in self.config.ema_spans:
            ema[f'ema{s}'] = close.ewm(span=s, adjust=False).mean()

        # MACD
        fast, slow, signal = self.config.macd
        ema_fast = close.ewm(span=fast, adjust=False).mean()
        ema_slow = close.ewm(span=slow, adjust=False).mean()
        macd_line = ema_fast - ema_slow
        signal_line = macd_line.ewm(span=signal, adjust=False).mean()
        macd_hist = macd_line - signal_line

        # RSI (Wilder smoothing)
        delta = close.diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.ewm(alpha=1 / self.config.rsi_period, adjust=False).mean()
        avg_loss = loss.ewm(alpha=1 / self.config.rsi_period, adjust=False).mean()
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))

        # ATR (Wilder)
        tr1 = high - low
        tr2 = (high - close.shift()).abs()
        tr3 = (low - close.shift()).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.ewm(alpha=1 / self.config.atr_period, adjust=False).mean()

        # BBW
        bb_mid = close.rolling(window=20).mean()
        bb_std = close.rolling(window=20).std()
        bb_upper = bb_mid + 2 * bb_std
        bb_lower = bb_mid - 2 * bb_std
        bbw = (bb_upper - bb_lower) / bb_mid

        # Stochastic
        lowest_low = low.rolling(window=14).min()
        highest_high = high.rolling(window=14).max()
        k_fast = 100 * (close - lowest_low) / (highest_high - lowest_low)
        d_slow = k_fast.rolling(window=3).mean()

        # ADX ç®€åŒ–
        plus_dm = high.diff()
        minus_dm = low.diff().abs()
        plus_dm[plus_dm < 0] = 0
        minus_dm[minus_dm < 0] = 0
        tr14 = tr.rolling(window=14).sum()
        plus_di = 100 * (plus_dm.ewm(alpha=1 / 14, adjust=False).sum() / tr14)
        minus_di = 100 * (minus_dm.ewm(alpha=1 / 14, adjust=False).sum() / tr14)
        dx = (abs(plus_di - minus_di) / (plus_di + minus_di)).replace([np.inf, -np.inf], 0) * 100
        adx = dx.ewm(alpha=1 / 14, adjust=False).mean()

        # OBV
        obv = (np.sign(close.diff()) * volume).fillna(0).cumsum()

        # CMF
        mfv = ((close - low) - (high - close)) / (high - low)
        mfv = mfv.replace([np.inf, -np.inf], 0).fillna(0)
        cmf = (mfv * volume).rolling(window=20).sum() / volume.rolling(window=20).sum()

        indicators = {
            **ema,
            'macd_hist': macd_hist, 'macd_line': macd_line, 'signal_line': signal_line,
            'rsi': rsi, 'atr': atr,
            'bb_upper': bb_upper, 'bb_lower': bb_lower, 'bbw': bbw,
            'stoch_k': k_fast, 'stoch_d': d_slow,
            'adx': adx, 'plus_di': plus_di, 'minus_di': minus_di,
            'obv': obv, 'cmf': cmf,
            'volume': volume, 'close': close,
        }
        return indicators

    def _evaluate_signal(self, df: pd.DataFrame, ind: dict, mode: str) -> dict:
        latest = df.iloc[-1]
        close_price = latest['close']

        ema_keys = [f'ema{s}' for s in self.config.ema_spans]
        trend = 'ä¸­æ€§'
        if all(ind[ema_keys[i]].iloc[-1] > ind[ema_keys[i+1]].iloc[-1] for i in range(len(ema_keys)-1)):
            trend = 'å¤šå¤´'
        elif all(ind[ema_keys[i]].iloc[-1] < ind[ema_keys[i+1]].iloc[-1] for i in range(len(ema_keys)-1)):
            trend = 'ç©ºå¤´'

        macd_hist_latest = ind['macd_hist'].iloc[-1]
        macd_state = 'æ­£å‘' if macd_hist_latest > 0 else 'è´Ÿå‘'

        rsi_latest = ind['rsi'].iloc[-1]
        if rsi_latest > self.config.rsi_overbought:
            rsi_state = 'è¶…ä¹°'
        elif rsi_latest < self.config.rsi_oversold:
            rsi_state = 'è¶…å–'
        else:
            rsi_state = 'ä¸­æ€§'

        vol_series = ind['volume']
        avg_vol = vol_series.rolling(window=20).mean().iloc[-1]
        vol_std = vol_series.rolling(window=20).std().iloc[-1] or 1e-8
        recent_vol = vol_series.iloc[-3:].mean()
        vol_z = (recent_vol - avg_vol) / vol_std
        vol_ok = vol_z > 1.2 or (recent_vol > self.config.vol_multiplier * avg_vol)

        atr_latest = ind['atr'].iloc[-1]
        stop_loss_long = close_price - self.config.atr_factor_max * atr_latest
        stop_loss_short = close_price + self.config.atr_factor_max * atr_latest

        support = ind[f'ema{self.config.ema_spans[-1]}'].iloc[-1]
        resistance = ind[f'ema{self.config.ema_spans[0]}'].iloc[-1]

        # ç®€å•è¯„åˆ†æœºåˆ¶
        score = 50
        if trend == 'å¤šå¤´': score += 20
        elif trend == 'ç©ºå¤´': score -= 20
        if macd_hist_latest > 0: score += 15
        else: score -= 15
        if mode == 'spot':
            if rsi_latest < 40: score += 10
            elif rsi_latest > 70: score -= 10
        else:
            if rsi_latest > 60: score += 10
            elif rsi_latest < 30: score -= 10
        if vol_ok: score += 15

        score = max(0, min(100, int(score)))
        if score >= 75:
            recommendation = 'å¼ºçƒˆå»ºè®®è¿›åœº'
        elif score >= 55:
            recommendation = 'å¯è€ƒè™‘è¿›åœºï¼ˆä¸­ç­‰ä¿¡å·ï¼‰'
        elif score >= 40:
            recommendation = 'è§‚æœ›ï¼ˆè–„å¼±ä¿¡å·ï¼‰'
        else:
            recommendation = 'é¿å…è¿›åœºï¼ˆå¼±ä¿¡å·ï¼‰'

        return {
            'price': float(round(close_price, 6)),
            'trend': trend,
            'macd_state': macd_state,
            'rsi_state': rsi_state,
            'rsi': float(round(rsi_latest, 4)),
            'volume_ok': bool(vol_ok),
            'recent_vol': float(round(recent_vol, 6)),
            'avg_vol': float(round(avg_vol, 6)) if not np.isnan(avg_vol) else None,
            'atr': float(round(atr_latest, 8)) if not np.isnan(atr_latest) else None,
            'stop_loss_long': float(round(stop_loss_long, 6)),
            'stop_loss_short': float(round(stop_loss_short, 6)),
            'support': float(round(support, 6)),
            'resistance': float(round(resistance, 6)),
            'score': score,
            'recommendation': recommendation,
            'mode': mode,
            'indicators': ind,
        }

# --------------------------- å›æµ‹å‡½æ•° --------------------------- #
def backtest_signals(df: pd.DataFrame, indicators: dict, entry_score_threshold: int = 55, exit_profit_take: float = 0.05, exit_stop_loss: float = 0.02) -> dict:
    """
    ç®€å•é€æ ¹ K çº¿å›æµ‹ï¼šå½“è¯„åˆ† â‰¥ entry_score_threshold æ—¶å¼€å¤šä»“ï¼ˆæ¬¡æ ¹æ”¶ç›˜å¼€ï¼‰ï¼ŒæŒä»“ç›´åˆ°è§¦åŠæ­¢ç›ˆæˆ–æ­¢æŸæˆ–è¢«å¯¹å†²æ¡ä»¶è§¦å‘ã€‚
    åªåšç¤ºä¾‹æ€§å¤šå¤´å›æµ‹ï¼ˆspotï¼‰ï¼Œä¸è®¡æ‰‹ç»­è´¹ä¸æ»‘ç‚¹ï¼ˆå¯æ‰©å±•ï¼‰ã€‚
    è¿”å›ï¼šèƒœç‡ã€æ€»æ”¶ç›Šã€å¹´åŒ–æ”¶ç›Šï¼ˆè¿‘ä¼¼ï¼‰ã€æœ€å¤§å›æ’¤ã€äº¤æ˜“æ˜ç»†
    """
    df = df.copy()
    close = df['close'].values
    n = len(df)

    # å…ˆç”Ÿæˆæ¯æ ¹ K çš„è¯„åˆ†ï¼ˆç¤ºä¾‹ä½¿ç”¨ macd+rsi+trend å¿«é€Ÿè¯„åˆ†ï¼Œå®é™…å¯ç”¨ä¹‹å‰è¯„ä¼°å‡½æ•°ï¼‰
    scores = []
    for i in range(n):
        try:
            # build a tiny snapshot
            score = 50
            # trend via EMAs
            ema_keys = [k for k in indicators.keys() if k.startswith('ema')]
            # if not enough data, default
            if i >= max([int(k.replace('ema', '')) for k in indicators if k.startswith('ema')]) if any(k.startswith('ema') for k in indicators) else 0:
                # compare last available values
                # here we simply use indicators last values (conservative approach)
                pass
            # macd
            m = indicators['macd_hist'].iloc[i]
            r = indicators['rsi'].iloc[i]
            if m > 0: score += 15
            else: score -= 15
            if r < 40: score += 10
            elif r > 70: score -= 10
            scores.append(score)
        except Exception:
            scores.append(50)

    positions = []  # list of (entry_index, entry_price, exit_index, exit_price, ret)
    in_pos = False
    entry_price = None
    entry_idx = None

    for i in range(1, n):
        s = scores[i-1]
        if not in_pos and s >= entry_score_threshold:
            # enter at next open/close approximation: we'll use close[i] as entry (conservative)
            entry_price = close[i]
            entry_idx = i
            in_pos = True
        elif in_pos:
            cur_price = close[i]
            ret = (cur_price - entry_price) / entry_price
            if ret >= exit_profit_take or ret <= -exit_stop_loss:
                positions.append((entry_idx, entry_price, i, cur_price, ret))
                in_pos = False
                entry_price = None
                entry_idx = None
    # if still in pos at end, close at last
    if in_pos and entry_price is not None:
        positions.append((entry_idx, entry_price, n-1, close[-1], (close[-1] - entry_price) / entry_price))

    # ç»Ÿè®¡
    if len(positions) == 0:
        return {'trades': [], 'total_return': 0.0, 'win_rate': None, 'max_drawdown': 0.0, 'equity_curve': [1.0]}

    returns = [p[4] for p in positions]
    equity = [1.0]
    for r in returns:
        equity.append(equity[-1] * (1 + r))
    total_return = equity[-1] - 1.0
    wins = [r for r in returns if r > 0]
    win_rate = len(wins) / len(returns)

    # max drawdown
    eq = np.array(equity)
    peak = np.maximum.accumulate(eq)
    dd = (eq - peak) / peak
    max_dd = float(np.min(dd)) if len(dd) > 0 else 0.0

    return {
        'trades': positions,
        'total_return': float(total_return),
        'win_rate': float(win_rate),
        'max_drawdown': float(max_dd),
        'equity_curve': equity,
    }

# --------------------------- UI ä¸»ä½“ï¼ˆå« pyqtgraph åµŒå…¥ï¼‰ --------------------------- #
class AnalyzerWindow(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Crypto Shortâ€‘Signal Analyzer v1.3")
        self.resize(1200, 760)

        self.config = AnalyzerConfig()
        self.worker: Optional[AnalysisWorker] = None
        self._last_result = None

        self._setup_ui()

    def _setup_ui(self):
        layout = QtWidgets.QGridLayout(self)

        # å·¦ä¾§æ§åˆ¶
        left_panel = QtWidgets.QGroupBox("âš™ï¸ å‚æ•°è®¾ç½®")
        left_layout = QtWidgets.QFormLayout(left_panel)

        self.symbol_edit = QtWidgets.QLineEdit("ETH")
        left_layout.addRow("ä»£å¸ (Symbol)", self.symbol_edit)

        self.mode_combo = QtWidgets.QComboBox()
        self.mode_combo.addItems(["ç°è´§ (spot)", "åˆçº¦ (futures)"])
        left_layout.addRow("äº¤æ˜“æ¨¡å¼", self.mode_combo)

        self.timeframe_combo = QtWidgets.QComboBox()
        self.timeframe_combo.addItems(["1m", "5m", "15m", "1h", "4h", "1d"])
        left_layout.addRow("Kçº¿å‘¨æœŸ", self.timeframe_combo)

        self.vol_multiplier_spin = QtWidgets.QDoubleSpinBox()
        self.vol_multiplier_spin.setRange(0.5, 10.0)
        self.vol_multiplier_spin.setSingleStep(0.1)
        self.vol_multiplier_spin.setValue(self.config.vol_multiplier)
        left_layout.addRow("æˆäº¤é‡æ”¾å¤§ç³»æ•°", self.vol_multiplier_spin)

        self.atr_min_spin = QtWidgets.QDoubleSpinBox()
        self.atr_min_spin.setRange(0.1, 5.0)
        self.atr_min_spin.setSingleStep(0.1)
        self.atr_min_spin.setValue(self.config.atr_factor_min)
        left_layout.addRow("ATR æ­¢æŸç³»æ•° (æœ€å°)", self.atr_min_spin)

        self.atr_max_spin = QtWidgets.QDoubleSpinBox()
        self.atr_max_spin.setRange(0.1, 10.0)
        self.atr_max_spin.setSingleStep(0.1)
        self.atr_max_spin.setValue(self.config.atr_factor_max)
        left_layout.addRow("ATR æ­¢æŸç³»æ•° (æœ€å¤§)", self.atr_max_spin)

        ext_group = QtWidgets.QGroupBox("ğŸ”§ å¯é€‰æ‰©å±•æŒ‡æ ‡")
        ext_layout = QtWidgets.QVBoxLayout(ext_group)
        self.chk_widgets = {}
        for k in self.config.ext.keys():
            chk = QtWidgets.QCheckBox(k)
            self.chk_widgets[k] = chk
            ext_layout.addWidget(chk)

        # è¿è¡Œ/ä¿å­˜/åŠ è½½/å›æµ‹
        self.run_btn = QtWidgets.QPushButton("â–¶ è¿è¡Œåˆ†æ")
        self.run_btn.clicked.connect(self.on_run_clicked)
        self.save_conf_btn = QtWidgets.QPushButton("ğŸ’¾ ä¿å­˜é…ç½®")
        self.save_conf_btn.clicked.connect(self.on_save_config)
        self.load_conf_btn = QtWidgets.QPushButton("ğŸ“‚ åŠ è½½é…ç½®")
        self.load_conf_btn.clicked.connect(self.on_load_config)
        self.backtest_btn = QtWidgets.QPushButton("ğŸ§ª è¿è¡Œå›æµ‹")
        self.backtest_btn.clicked.connect(self.on_backtest_clicked)
        self.backtest_btn.setEnabled(False)

        left_layout.addRow(self.run_btn)
        left_layout.addRow(self.save_conf_btn)
        left_layout.addRow(self.load_conf_btn)
        left_layout.addRow(self.backtest_btn)

        # å³ä¾§å›¾å½¢ä¸ç»“æœ
        right_vbox = QtWidgets.QVBoxLayout()

        # pyqtgraph plot area
        self.plot_widget = pg.PlotWidget(title="Price & EMAs")
        self.plot_widget.setBackground('w')
        self.plot_widget.addLegend()
        self.plot_widget.showGrid(x=True, y=True)

        # result text
        self.result_text = QtWidgets.QPlainTextEdit()
        self.result_text.setReadOnly(True)
        self.result_text.setMaximumHeight(220)

        right_vbox.addWidget(self.plot_widget, 3)
        right_vbox.addWidget(self.result_text, 1)

        layout.addWidget(left_panel, 0, 0, 2, 1)
        layout.addLayout(ext_layout, 2, 0, 1, 1)
        layout.addLayout(right_vbox, 0, 1, 6, 2)

    def on_run_clicked(self):
        symbol = self.symbol_edit.text().strip()
        if not symbol:
            QtWidgets.QMessageBox.warning(self, "è¾“å…¥é”™è¯¯", "è¯·è¾“å…¥ä»£å¸ Symbolï¼Œä¾‹å¦‚ï¼šETH")
            return
        symbol_clean = re.sub(r'[^A-Za-z0-9]', '', symbol).upper()
        if not symbol_clean:
            QtWidgets.QMessageBox.warning(self, "è¾“å…¥é”™è¯¯", "ä»£å¸ Symbol åŒ…å«éæ³•å­—ç¬¦")
            return

        timeframe = self.timeframe_combo.currentText()
        mode_text = self.mode_combo.currentText()
        mode = 'spot' if 'spot' in mode_text else 'futures'

        # æ›´æ–° config
        self.config.vol_multiplier = self.vol_multiplier_spin.value()
        self.config.atr_factor_min = self.atr_min_spin.value()
        self.config.atr_factor_max = self.atr_max_spin.value()
        for k, chk in self.chk_widgets.items():
            self.config.ext[k] = chk.isChecked()

        self.run_btn.setEnabled(False)
        self.result_text.setPlainText('â³ åå°æ‹‰å–æ•°æ®å¹¶è®¡ç®—ä¸­...')
        self.plot_widget.clear()
        self.backtest_btn.setEnabled(False)

        if self.worker is not None and self.worker.isRunning():
            try:
                self.worker.stop()
                self.worker.wait(2000)
            except Exception:
                pass

        self.worker = AnalysisWorker(symbol_clean, timeframe, mode, self.config, fetch_limit=500)
        self.worker.finished.connect(self.on_worker_finished)
        self.worker.error.connect(self.on_worker_error)
        self.worker.start()

    def on_worker_finished(self, result: dict):
        self.run_btn.setEnabled(True)
        self.backtest_btn.setEnabled(True)
        self._last_result = result
        txt = self._format_result_text(result)
        self.result_text.setPlainText(txt)
        self._plot_result(result)

    def on_worker_error(self, msg: str):
        self.run_btn.setEnabled(True)
        self.backtest_btn.setEnabled(False)
        self.result_text.setPlainText(f"âŒ åå°é”™è¯¯:\n{msg}")

    def _format_result_text(self, res: dict) -> str:
        lines = [
            f"ğŸª™ ä»£å¸: {self.symbol_edit.text().strip().upper()}   â° Kçº¿å‘¨æœŸ: {self.timeframe_combo.currentText()}",
            f"ğŸ’° å½“å‰ä»·æ ¼: ${res['price']}",
            f"ğŸ“Š è¶‹åŠ¿åˆ¤æ–­: {res['trend']}",
            f"âš¡ åŠ¨èƒ½ (MACD): {res['macd_state']}",
            f"ğŸ“ˆ RSI: {res['rsi']}  â†’  {res['rsi_state']}",
            f"ğŸ“Š æˆäº¤é‡æ”¾å¤§: {'âœ”ï¸ æ»¡è¶³' if res['volume_ok'] else 'âŒ ä¸æ»¡è¶³'}",
            f"    - æœ€è¿‘ 3 æ ¹ K çº¿å‡é‡: {res['recent_vol']}",
            f"    - 20 æ ¹å‡é‡: {res['avg_vol']}",
            f"ğŸ“ ATR: {res['atr']}",
            f"    - å¤šå¤´æ­¢æŸä»·: ${res['stop_loss_long']}",
            f"    - ç©ºå¤´æ­¢æŸä»·: ${res['stop_loss_short']}",
            f"ğŸ›¡ï¸ æ”¯æ’‘ / é˜»åŠ›: ${res['support']}  /  ${res['resistance']}",
            f"ğŸ”¢ ç»¼åˆè¯„åˆ†: {res['score']}  â†’  {res['recommendation']}",
        ]
        lines.append('\nâš ï¸ é£é™©æç¤º:')
        lines.append('   â€¢ ä»…ä¾›å‚è€ƒï¼Œå®é™…äº¤æ˜“è¯·ç»“åˆè‡ªèº«é£é™©æ‰¿å—èƒ½åŠ›')
        lines.append('   â€¢ å»ºè®®ä»“ä½ â‰¤ 2â€‘3% è´¦æˆ·å‡€å€¼ï¼Œæ­¢æŸ/æ­¢ç›ˆæ¯” â‰¥ 1:1.5')
        return '\n'.join(lines)

    def _plot_result(self, result: dict):
        self.plot_widget.clear()
        ind = result.get('indicators')
        df = result.get('df')
        if ind is None or df is None:
            return

        x = np.arange(len(df))
        close = ind['close'].values
        pen_close = pg.mkPen(width=1.2, style=QtCore.Qt.SolidLine)
        self.plot_widget.plot(x, close, pen=pen_close, name='Close')

        for s in self.config.ema_spans:
            key = f'ema{s}'
            if key in ind:
                y = ind[key].values
                pen = pg.mkPen(width=1.0, style=QtCore.Qt.DashLine)
                self.plot_widget.plot(x, y, pen=pen, name=f'EMA{s}')

        # æ˜¾ç¤ºæœ€åä»·æ ¼æ¨ªçº¿
        last_price = result['price']
        self.plot_widget.addLine(y=last_price, pen=pg.mkPen('r', style=QtCore.Qt.DotLine))

        # æ·»åŠ ç¼©æ”¾ã€æ‹–æ‹½æ”¯æŒï¼ˆpyqtgraph é»˜è®¤å¯ç”¨ï¼‰
        self.plot_widget.enableAutoRange()

    # ----------------- é…ç½®å¯¼å…¥å¯¼å‡º -----------------
    def on_save_config(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, 'ä¿å­˜é…ç½®ä¸º JSON', 'config.json', 'JSON Files (*.json)')
        if not path:
            return
        try:
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(self.config.to_dict(), f, ensure_ascii=False, indent=2)
            QtWidgets.QMessageBox.information(self, 'ä¿å­˜æˆåŠŸ', f'é…ç½®å·²ä¿å­˜: {path}')
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, 'ä¿å­˜å¤±è´¥', str(e))

    def on_load_config(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'åŠ è½½é…ç½® JSON', '', 'JSON Files (*.json)')
        if not path:
            return
        try:
            with open(path, 'r', encoding='utf-8') as f:
                d = json.load(f)
            self.config = AnalyzerConfig.from_dict(d)
            # æ›´æ–° UI æ§ä»¶æ˜¾ç¤º
            self.vol_multiplier_spin.setValue(self.config.vol_multiplier)
            self.atr_min_spin.setValue(self.config.atr_factor_min)
            self.atr_max_spin.setValue(self.config.atr_factor_max)
            for k, chk in self.chk_widgets.items():
                chk.setChecked(bool(self.config.ext.get(k, False)))
            QtWidgets.QMessageBox.information(self, 'åŠ è½½æˆåŠŸ', f'é…ç½®å·²åŠ è½½: {path}')
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, 'åŠ è½½å¤±è´¥', str(e))

    # ----------------- å›æµ‹æŒ‰é’® -----------------
    def on_backtest_clicked(self):
        if self._last_result is None:
            QtWidgets.QMessageBox.information(self, 'æ— æ•°æ®', 'è¯·å…ˆè¿è¡Œä¸€æ¬¡åˆ†æä»¥è·å–å†å²æ•°æ®')
            return
        df = self._last_result.get('df')
        ind = self._last_result.get('indicators')
        if df is None or ind is None:
            QtWidgets.QMessageBox.information(self, 'æ— æ•°æ®', 'ç¼ºå°‘å›æµ‹æ‰€éœ€æ•°æ®')
            return

        # è¿è¡Œå›æµ‹ï¼ˆå‚æ•°å¯æ‰©å±•ä¸º UI è¾“å…¥ï¼‰
        bt = backtest_signals(df, ind, entry_score_threshold=55, exit_profit_take=0.05, exit_stop_loss=0.02)
        trades = bt['trades']
        total_return = bt['total_return']
        win_rate = bt['win_rate']
        max_dd = bt['max_drawdown']

        txt = self.result_text.toPlainText()
        txt += '\n\nğŸ§ª å›æµ‹ç»“æœï¼ˆç¤ºä¾‹ï¼‰:\n'
        txt += f'   â€¢ äº¤æ˜“æ¬¡æ•°: {len(trades)}\n'
        txt += f'   â€¢ æ€»æ”¶ç›Šç‡ï¼ˆä¼°ç®—ï¼‰: {total_return * 100:.2f}%\n'
        txt += f'   â€¢ èƒœç‡: {win_rate * 100:.2f}%\n'
        txt += f'   â€¢ æœ€å¤§å›æ’¤: {max_dd * 100:.2f}%\n'
        self.result_text.setPlainText(txt)

# --------------------------- ç¨‹åºå…¥å£ --------------------------- #
if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    win = AnalyzerWindow()
    win.show()
    sys.exit(app.exec_())

# --------------------------- PyInstaller æ‰“åŒ…è¯´æ˜ --------------------------- #
# å»ºè®®åœ¨è™šæ‹Ÿç¯å¢ƒä¸­æ“ä½œï¼š
# 1) åˆ›å»ºå¹¶æ¿€æ´» venv
#    python -m venv venv
#    venv\Scripts\activate  (Windows)
# 2) å®‰è£…ä¾èµ–ï¼š
#    pip install -U pip
#    pip install ccxt pandas numpy PyQt5 pyqtgraph
# 3) ç”Ÿæˆå•æ–‡ä»¶å¯æ‰§è¡Œï¼ˆç¤ºä¾‹ï¼‰:
#    pip install pyinstaller
#    pyinstaller --noconfirm --onefile --windowed --add-data "<python_env>\\Lib\\site-packages\\pyqtgraph;pyqtgraph" crypto_analyzer_v1_3.py
# æ³¨æ„ï¼šWindows ä¸‹ --add-data å‚æ•°éœ€è¦ä½¿ç”¨åˆ†å·åˆ†éš”ç›®çš„åœ°ï¼ˆä¸Šé¢ç¤ºä¾‹éœ€æ›¿æ¢ä¸ºä½ ç¯å¢ƒçš„å®é™…è·¯å¾„ï¼‰ï¼Œå¦å¤– PyQt5 èµ„æºå¯èƒ½éœ€è¦é¢å¤–åŒ…å«ã€‚è‹¥æ‰“åŒ…å‡ºç°ç¼ºå°‘åº“ï¼Œæ¨èå…ˆç”¨ --onedir è°ƒè¯•ï¼š
#    pyinstaller --noconfirm --onedir --windowed crypto_analyzer_v1_3.py
# 4) è‹¥éœ€è¦å¸®åŠ©æˆ‘ç”Ÿæˆä¸€ä¸ªé€‚é…ä½ è·¯å¾„çš„æ‰“åŒ… .bat æˆ– .ps1 è„šæœ¬ï¼Œæˆ‘å¯ä»¥æŠŠè„šæœ¬å†…å®¹æ”¾åœ¨æ–‡ä»¶é‡Œä¾›ä½ ç›´æ¥è¿è¡Œï¼ˆä½†æˆ‘ä¸èƒ½åœ¨å½“å‰ç¯å¢ƒæ›¿ä½ æ‰§è¡Œæ‰“åŒ…ï¼‰ã€‚
